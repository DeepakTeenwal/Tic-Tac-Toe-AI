<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tic-Tac-Toe - Multiplayer</title>
  <!-- Farcaster Mini App Metadata -->
  <meta name="fc:miniapp" content='{
      "version":"1",
      "imageUrl":"https://tic-tac-toe-ai-lac.vercel.app/image.png",
      "button":{
        "title":"Play Tic-Tac-Toe",
        "action":{
          "type":"launch_frame",
          "name":"LAUNCH",
          "url":"https://tic-tac-toe-ai-lac.vercel.app/",
          "splashImageUrl":"https://tic-tac-toe-ai-lac.vercel.app/splash.png",
          "splashBackgroundColor":"#1B1B1E"
          }
        }
    }' />
  <style>
    :root {
      --primary: #0f172a;
      --secondary: #1e293b;
      --accent: #0ea5e9;
      --win: #10b981;
      --lose: #ef4444;
      --draw: #f59e0b;
      --text: #e2e8f0;
      --subtle: #64748b;
      --cell-size: min(25vw, 120px);
      --transition: all .3s cubic-bezier(.4,0,.2,1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }

    body {
      display: grid;
      place-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--text);
      padding: 2rem;
      position: relative;
    }

    h1 {
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: 700;
      text-align: center;
      margin-bottom: 1rem;
      letter-spacing: .05em;
    }

    #status {
      text-align: center;
      font-size: 1.125rem;
      min-height: 1.5em;
      margin-bottom: 1.5rem;
      transition: var(--transition);
    }

    #board {
      display: grid;
      grid-template-columns: repeat(3, var(--cell-size));
      grid-template-rows: repeat(3, var(--cell-size));
      gap: 8px;
      margin: 0 auto 2rem;
      position: relative;
    }

    .cell {
      background: var(--secondary);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(var(--cell-size) * .45);
      cursor: pointer;
      transition: var(--transition);
      user-select: none;
    }

    .cell:hover {
      background: #334155;
    }

    .cell.x {
      color: var(--accent);
    }

    .cell.o {
      color: var(--win);
    }

    .cell.disabled {
      pointer-events: none;
    }

    #score {
      display: flex;
      justify-content: space-evenly;
      gap: 1rem;
      margin-bottom: 1.5rem;
      font-size: 1rem;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: .25rem;
      color: var(--subtle);
    }

    .score-item span:last-child {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text);
    }

    button {
      display: block;
      margin: 0 auto 0.5rem;
      padding: .75rem 2rem;
      border: none;
      border-radius: 999px;
      background: var(--accent);
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
      transition: var(--transition);
    }

    button:hover {
      background: #0284c7;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    .win-line {
      position: absolute;
      background: var(--win);
      border-radius: 4px;
      transition: var(--transition);
      opacity: 0;
    }

    .win-line.show {
      opacity: 1;
    }

    .connect-btn {
      background: var(--lose);
    }

    .invite-btn {
      background: #8b5cf6;
    }

    .add-favorite-btn {
      background: var(--draw);
    }

    .mode-selector {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .mode-btn {
      padding: .5rem 1.5rem;
      font-size: 0.9rem;
      background: var(--secondary);
    }

    .mode-btn.active {
      background: var(--accent);
    }

    @media (max-width: 400px) {
      #board {
        grid-template-columns: repeat(3, 80px);
        grid-template-rows: repeat(3, 80px);
      }
      button {
        padding: .5rem 1.5rem;
        font-size: 0.8rem;
      }
    }
  </style>
  
  <!-- Farcaster SDK -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    window.sdk = sdk;
  </script>

  <!-- Wagmi/Viem -->
  <script type="module">
    import {
      createConfig,
      connect,
      writeContract,
      readContract,
      getAccount,
      getChainId,
      switchChain,
      http,
      waitForTransactionReceipt
    } from 'https://esm.sh/@wagmi/core';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
    import { parseEther } from 'https://esm.sh/viem';
    import { base } from 'https://esm.sh/wagmi/chains';

    // Create Wagmi config
    const config = createConfig({
      chains: [base],
      transports: {
        [base.id]: http(),
      },
      connectors: [farcasterMiniApp()]
    });

    window.WAGMI_CONFIG = config;
    window.WAGMI_CORE = {
      connect,
      writeContract,
      readContract,
      getAccount,
      getChainId,
      switchChain,
      waitForTransactionReceipt
    };
    window.VIEM = { parseEther };
  </script>
</head>
<body>
  <h1>Tic-Tac-Toe</h1>
  
  <div class="mode-selector">
    <button class="mode-btn active" onclick="setGameMode('ai')">vs AI</button>
    <button class="mode-btn" onclick="setGameMode('friend')">vs Friend</button>
  </div>

  <div id="status">Your turn (X)</div>
  
  <div id="board">
    <div class="cell" data-index="0"></div>
    <div class="cell" data-index="1"></div>
    <div class="cell" data-index="2"></div>
    <div class="cell" data-index="3"></div>
    <div class="cell" data-index="4"></div>
    <div class="cell" data-index="5"></div>
    <div class="cell" data-index="6"></div>
    <div class="cell" data-index="7"></div>
    <div class="cell" data-index="8"></div>
    <div class="win-line"></div>
  </div>

  <div id="score">
    <div class="score-item">
      <span>You</span>
      <span id="playerScore">0</span>
    </div>
    <div class="score-item">
      <span>Draws</span>
      <span id="drawScore">0</span>
    </div>
    <div class="score-item">
      <span id="opponentLabel">Bot</span>
      <span id="botScore">0</span>
    </div>
  </div>

  <button onclick="restartGame()">Restart Game</button>
  <button id="connectButton" class="connect-btn" onclick="connectWallet()">Connect Wallet</button>
  <button id="inviteButton" class="invite-btn" style="display: none;" onclick="inviteFriend()">Invite Friend to Play</button>
  <button id="addFavoriteButton" class="add-favorite-btn" onclick="addToFavorites()">Add to Favorites</button>

  <script>
    let cells = document.querySelectorAll('.cell');
    let statusEl = document.getElementById('status');
    let winLine = document.querySelector('.win-line');
    let board = Array(9).fill(null);
    let gameOver = false;
    let scores = { player: 0, draw: 0, bot: 0 };
    let userAddress = null;
    let isConnected = false;
    let currentUser = null;
    let gameMode = 'ai'; // 'ai' or 'friend'
    let currentPlayer = 'x';
    let features = null;

    const winPatterns = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
    ];

    cells.forEach(c => c.addEventListener('click', handlePlayerMove));

    // Initialize the app
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        await window.sdk.actions.ready({ disableNativeGestures: true });

        // Get user context
        const context = await window.sdk.getContext();
        currentUser = context.user;
        
        statusEl.textContent = `Welcome ${currentUser.displayName || currentUser.username}! Your turn (X)`;
        console.log(`User FID: ${currentUser.fid}`);

        // Check capabilities
        const capabilities = await window.sdk.getCapabilities();
        features = await window.sdk.getFeatures();
        
        if (!capabilities.wallet) {
          console.log('Wallet not supported in this client');
          document.getElementById('connectButton').style.display = 'none';
        }

        // Auto-connect wallet if available
        await checkWalletConnection();

      } catch (err) {
        console.error('SDK initialization failed:', err);
        statusEl.textContent = 'Error loading app. Try refreshing.';
      }
    });

    // Check if wallet is already connected
    async function checkWalletConnection() {
      try {
        const account = window.WAGMI_CORE.getAccount(window.WAGMI_CONFIG);
        if (account && account.isConnected) {
          userAddress = account.address;
          isConnected = true;
          updateConnectionStatus();
        }
      } catch (err) {
        console.log('Wallet not auto-connected');
      }
    }

    // Connect wallet using Wagmi
    async function connectWallet() {
      try {
        statusEl.textContent = 'Connecting wallet...';
        
        const result = await window.WAGMI_CORE.connect(window.WAGMI_CONFIG, {
          connector: window.WAGMI_CONFIG.connectors[0]
        });

        userAddress = result.accounts[0];
        isConnected = true;
        
        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ type: 'success' });
        }

        updateConnectionStatus();
        statusEl.textContent = `Wallet connected! Your turn (X)`;
        
      } catch (err) {
        console.error('Wallet connection failed:', err);
        statusEl.textContent = `Connection failed: ${err.message}`;
        
        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ type: 'failure' });
        }
      }
    }

    function updateConnectionStatus() {
      if (isConnected && userAddress) {
        document.getElementById('connectButton').style.display = 'none';
        document.getElementById('inviteButton').style.display = 'block';
      }
    }

    // Set game mode
    function setGameMode(mode) {
      gameMode = mode;
      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      const opponentLabel = document.getElementById('opponentLabel');
      opponentLabel.textContent = mode === 'ai' ? 'Bot' : 'Friend';
      
      restartGame();
    }

    // Invite friend to play
    async function inviteFriend() {
      try {
        const shareUrl = `${window.location.origin}?mode=friend&invite=${currentUser.fid}`;
        
        // Use SDK to post a cast inviting a friend
        await window.sdk.actions.post({
          text: `Challenge me to Tic-Tac-Toe! 🎮\n\nPlay here: ${shareUrl}`,
        });

        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ type: 'success' });
        }

        statusEl.textContent = 'Invitation sent! Waiting for friend...';
      } catch (err) {
        console.error('Failed to send invitation:', err);
        statusEl.textContent = `Failed to invite: ${err.message}`;
      }
    }

    // Add app to favorites
    async function addToFavorites() {
      try {
        await window.sdk.actions.addMiniApp();
        
        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ type: 'success' });
        }

        statusEl.textContent = 'Added to favorites! You can now receive notifications.';
        
        // Hide the button after adding
        document.getElementById('addFavoriteButton').style.display = 'none';
        
      } catch (err) {
        console.error('Failed to add to favorites:', err);
        
        if (err.message.includes('production domain')) {
          statusEl.textContent = 'Add to favorites only works on production domain';
        } else {
          statusEl.textContent = `Failed to add: ${err.message}`;
        }
      }
    }

    function handlePlayerMove(e) {
      const idx = e.target.dataset.index;
      if (board[idx] || gameOver) return;

      if (gameMode === 'friend') {
        // In friend mode, alternate between X and O
        makeMove(idx, currentPlayer);
        currentPlayer = currentPlayer === 'x' ? 'o' : 'x';
        if (!gameOver) {
          statusEl.textContent = `${currentPlayer === 'x' ? 'Player X' : 'Player O'}'s turn`;
        }
      } else {
        // AI mode
        makeMove(idx, 'x');
        if (!gameOver) {
          statusEl.textContent = 'Bot is thinking...';
          setTimeout(() => {
            makeMove(bestMove(), 'o');
            if (!gameOver) {
              statusEl.textContent = 'Your turn (X)';
            }
          }, 400);
        }
      }
    }

    function makeMove(idx, player) {
      board[idx] = player;
      cells[idx].textContent = player === 'x' ? 'X' : 'O';
      cells[idx].classList.add(player, 'disabled');
      
      const winner = checkWinner();
      if (winner) endGame(winner);
      else if (board.every(Boolean)) endGame('draw');
    }

    function checkWinner(b = board) {
      for (const [a, bIdx, c] of winPatterns) {
        if (b[a] && b[a] === b[bIdx] && b[a] === b[c]) return b[a];
      }
      return null;
    }

    async function endGame(result) {
      gameOver = true;
      cells.forEach(c => c.classList.add('disabled'));
      
      if (result === 'draw') {
        statusEl.textContent = 'It\'s a draw!';
        scores.draw++;
        document.getElementById('drawScore').textContent = scores.draw;
        
        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ type: 'light' });
        }
      } else {
        const isPlayerWin = (gameMode === 'ai' && result === 'x') || 
                           (gameMode === 'friend' && result === currentPlayer);
        
        if (result === 'x') {
          statusEl.textContent = gameMode === 'ai' ? 'You win!' : 'Player X wins!';
          scores.player++;
          document.getElementById('playerScore').textContent = scores.player;
        } else {
          statusEl.textContent = gameMode === 'ai' ? 'Bot wins!' : 'Player O wins!';
          scores.bot++;
          document.getElementById('botScore').textContent = scores.bot;
        }

        if (features?.haptics) {
          await window.sdk.actions.hapticFeedback({ 
            type: result === 'x' ? 'success' : 'failure' 
          });
        }
      }

      // Share result
      const shareUrl = `${window.location.origin}?result=${result}&mode=${gameMode}`;
      const resultText = result === 'draw' ? 'Draw!' : 
                        result === 'x' ? 'Player X won!' : 'Player O won!';
      
      try {
        await window.sdk.actions.post({
          text: `Tic-Tac-Toe ${gameMode === 'ai' ? 'vs AI' : 'with Friend'}: ${resultText}\nPlay me: ${shareUrl}`,
        });
      } catch (err) {
        console.error('Failed to post result:', err);
      }
    }

    function bestMove() {
      return minimax(board, 'o').index;
    }

    function minimax(newBoard, player) {
      const availSpots = newBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
      if (checkWinner(newBoard) === 'x') return { score: -10 };
      if (checkWinner(newBoard) === 'o') return { score: 10 };
      if (availSpots.length === 0) return { score: 0 };
      
      const moves = [];
      for (let i = 0; i < availSpots.length; i++) {
        const move = {};
        move.index = availSpots[i];
        newBoard[availSpots[i]] = player;
        move.score = (player === 'o') ? minimax(newBoard, 'x').score : minimax(newBoard, 'o').score;
        newBoard[availSpots[i]] = null;
        moves.push(move);
      }
      
      let bestMove;
      if (player === 'o') {
        let bestScore = -Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score > bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      } else {
        let bestScore = Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score < bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      }
      return moves[bestMove];
    }

    function restartGame() {
      board = Array(9).fill(null);
      gameOver = false;
      currentPlayer = 'x';
      
      cells.forEach(c => {
        c.textContent = '';
        c.className = 'cell';
      });
      
      winLine.className = 'win-line';
      statusEl.textContent = gameMode === 'ai' ? 'Your turn (X)' : 'Player X\'s turn';
    }
  </script>
</body>
</html>
